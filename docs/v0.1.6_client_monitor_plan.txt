--[ PORKCHOP v0.1.6 - CLIENT MONITOR IMPLEMENTATION PLAN

    Feature: Extend SPECTRUM mode with client monitoring overlay
    Codename: "HOG WATCH" or "BACON BITS"
    Author: 0ct0 + Copilot
    Created: December 17, 2025
    Revised: December 17, 2025 (added bug mitigation strategy)
    
    This document is the single source of truth for implementation.
    Refer to this file when resuming work to avoid hallucination.


--[ KNOWN PITFALLS & MITIGATIONS

    These bugs WILL happen if we don't guard against them upfront.
    Each phase references specific mitigations by number.

    [P1] CALLBACK RACE CONDITIONS
         Problem: Promiscuous callback runs in WiFi task context while
                  main loop iterates client array. Classic data race.
         Mitigation: Use `spectrumBusy` volatile bool guard (like OINK).
                     Callback skips processing when busy flag is set.
                     Main loop sets busy=true before ANY array iteration.

    [P2] NETWORK DISAPPEARS WHILE MONITORING
         Problem: Monitored network goes stale and gets pruned.
                  monitoredNetworkIndex now points to garbage or wrong network.
         Mitigation: Store monitored BSSID separately (not just index).
                     On each update(), verify networks[idx].bssid matches.
                     If mismatch or network gone, auto-exit monitor mode.

    [P3] INDEX OUT OF BOUNDS
         Problem: selectedClientIndex or monitoredNetworkIndex becomes
                  invalid after array modification (client pruned, network pruned).
         Mitigation: Always bounds-check before array access:
                     if (idx < 0 || idx >= (int)arr.size()) return;
                     After any removal, clamp indices: idx = min(idx, size-1).

    [P4] CHANNEL HOPPING NOT RESUMING
         Problem: Crash or weird state leaves channel locked forever.
         Mitigation: In stop() and in any error path, force:
                     monitoringNetwork = false;
                     No persistent state - hopping resumes on next update().

    [P5] CALLBACK DURING STATE TRANSITION
         Problem: enterClientMonitor() half-complete when callback fires.
         Mitigation: Set busy=true FIRST in enter/exit functions.
                     Only set monitoringNetwork after all state is ready.
                     Order: busy=true -> setup state -> monitoringNetwork=true -> busy=false

    [P6] MEMORY PRESSURE FROM CLIENTS
         Problem: 8 clients × N networks × 12 bytes each = memory growth.
         Mitigation: Only track clients for CURRENTLY MONITORED network.
                     Clear client array when exiting monitor mode.
                     Networks not being monitored have clientCount=0.

    [P7] OUI BINARY SEARCH CORRUPTION
         Problem: OUI table not sorted = binary search returns wrong vendor.
         Mitigation: Add build-time assertion that table is sorted.
                     Or use linear search for 500 entries (~50μs, acceptable).
                     Include "selftest" function called on first use.

    [P8] MAC COMPARISON PITFALLS
         Problem: memcmp on 6-byte array, but passing wrong pointer.
         Mitigation: Always use explicit memcmp(a, b, 6) with sizeof check.
                     Never compare MAC as uint64 without proper masking.
                     Add inline helper: bool macEqual(const uint8_t* a, const uint8_t* b)

    [P9] STRING TRUNCATION BUFFER OVERFLOW
         Problem: snprintf to fixed buffer without checking return value.
         Mitigation: All SSID displays use helper that truncates safely.
                     Vendor names in OUI table are max 9 chars + null.
                     Never strcpy, always strncpy with explicit null termination.

    [P10] STALE CLEANUP RACE
          Problem: Pruning clients while callback might be adding one.
          Mitigation: Set busy=true during prune. Callback will skip.
                      Don't iterate with for-each; use index-based loop
                      that handles removal correctly (iterate backwards).

    [P11] UI STATE DESYNC
          Problem: Keyboard input goes to wrong handler (spectrum vs monitor).
          Mitigation: Single check at TOP of handleInput():
                      if (monitoringNetwork) { handleMonitorInput(); return; }
                      No fall-through, no shared key handling.

    [P12] XP BAR COVERED BY OVERLAY
          Problem: Client overlay draws over XP bar at y=91.
          Mitigation: Overlay uses mainCanvas only (y=0-90 max).
                      Or draw overlay BEFORE XP bar is composited.
                      Verify in testing with XP bar visible.

    [P13] BOAR BROS EXCLUSION CHECK
          Problem: User monitors network, presses B to exclude,
                   but we don't exit monitor mode - now monitoring excluded net.
          Mitigation: After B key adds to BOAR BROS, auto-exit monitor mode.
                      Show toast "Network excluded, returning to spectrum".

    [P14] EMPTY CLIENT LIST CRASH
          Problem: selectedClientIndex = 0 but clientCount = 0.
          Mitigation: Check clientCount > 0 before ANY client access.
                      Show "No clients detected" message in overlay.
                      Disable Enter key when no clients.

    [P15] HIDDEN NETWORK DISPLAY
          Problem: Monitored network has empty SSID, display looks broken.
          Mitigation: Check ssid[0] == 0, display "<hidden>" or BSSID instead.
                      Same pattern as existing OINK mode hidden handling.


--[ FEATURE SUMMARY

    When user presses Enter on a selected network in SPECTRUM mode:
    1. Lock channel to that network's channel (stop hopping)
    2. Start capturing data frames (To-DS/From-DS)
    3. Track clients connected to that specific network
    4. Display client list overlay with MAC vendor identification
    5. Press backtick or Enter again to return to spectrum view


--[ CURRENT STATE ANALYSIS

    SPECTRUM MODE (src/modes/spectrum.cpp, ~650 lines):
    - Captures beacon/probe frames ONLY (subtypes 0x80, 0x50)
    - Does NOT capture data frames
    - Has busy guard pattern for callback safety
    - Has channel hopping (100ms per channel)
    - Has network selection via Enter (currently just centers view)
    - Uses SpectrumNetwork struct (no client tracking)
    
    OINK MODE (src/modes/oink.cpp, ~2451 lines):
    - HAS full client tracking in processDataFrame()
    - Uses DetectedClient struct: { mac[6], rssi, lastSeen }
    - Tracks up to 8 clients per network (MAX_CLIENTS_PER_NETWORK)
    - trackClient() function at line 2101
    - Data frame parsing at lines 1193-1220
    
    UI PATTERNS (src/ui/):
    - Toast: showToast() - pink box, black text, centered
    - Detail popup: drawDetail() pattern in achievements_menu.cpp
    - List view: scrolling with ; and ., highlight selected
    - Bottom overlay: setBottomOverlay() for context hints
    - Colors: COLOR_FG, COLOR_BG macros (theme-aware)


--[ IMPLEMENTATION PHASES

====[ PHASE 1: DATA STRUCTURES ]====

    Mitigations: [P1] [P2] [P6] [P8]
    
    Files to modify:
    - src/modes/spectrum.h
    
    Changes:
    1. Add DetectedClient struct (copy from oink.h or share via header)
       struct SpectrumClient {
           uint8_t mac[6];
           int8_t rssi;
           uint32_t lastSeen;
       };
    
    2. Add client tracking to SpectrumNetwork struct:
       SpectrumClient clients[MAX_SPECTRUM_CLIENTS];  // 8 max
       uint8_t clientCount;
    
    3. Add monitoring state:
       static volatile bool spectrumBusy;  // [P1] Guard for callback race
       static bool monitoringNetwork;      // True when locked on network
       static int monitoredNetworkIndex;   // Index of network being monitored
       static uint8_t monitoredBSSID[6];   // [P2] Store BSSID, not just index!
       static uint8_t monitoredChannel;    // Locked channel
       static int clientScrollOffset;      // For scrolling client list
       static int selectedClientIndex;     // Currently highlighted client
    
    4. Add new methods:
       static void enterClientMonitor();   // Enter overlay mode
       static void exitClientMonitor();    // Return to spectrum
       static void drawClientOverlay(M5Canvas& canvas);  // Draw client list
       static void trackClient(const uint8_t* bssid, const uint8_t* clientMac, int8_t rssi);
       static void processDataFrame(const uint8_t* payload, uint16_t len, int8_t rssi);
       
    5. Add helper macro [P8]:
       inline bool macEqual(const uint8_t* a, const uint8_t* b) {
           return memcmp(a, b, 6) == 0;
       }

    New constants:
    #define MAX_SPECTRUM_CLIENTS 8
    #define CLIENT_STALE_TIMEOUT_MS 30000  // 30s before client considered gone
    
    IMPORTANT [P6]: Clients array lives in SpectrumNetwork BUT we only 
    populate it for the ONE network being monitored. All other networks 
    keep clientCount=0. Clear clients on exitClientMonitor().


====[ PHASE 2: DATA FRAME CAPTURE ]====

    Mitigations: [P1] [P2] [P3] [P8]
    
    Files to modify:
    - src/modes/spectrum.cpp
    
    Changes to promiscuousCallback():
    1. Add busy guard at TOP of callback [P1]:
       
       if (spectrumBusy) return;  // Main thread is iterating
       
    2. Add data frame handling when monitoringNetwork is true:
       
       if (type == WIFI_PKT_DATA && monitoringNetwork) {
           processDataFrame(payload, len, rssi);
           return;
       }
    
    3. Implement processDataFrame() - copy pattern from oink.cpp:1193-1220
       
       void SpectrumMode::processDataFrame(const uint8_t* payload, uint16_t len, int8_t rssi) {
           if (len < 24) return;  // Too short for valid data frame
           
           uint8_t frameControl = payload[0];
           uint8_t toDS = (frameControl & 0x01);
           uint8_t fromDS = (frameControl & 0x02) >> 1;
           
           uint8_t bssid[6];
           uint8_t clientMac[6];
           
           if (toDS && !fromDS) {
               // Client -> AP: addr1=BSSID, addr2=client
               memcpy(bssid, payload + 4, 6);
               memcpy(clientMac, payload + 10, 6);
           } else if (!toDS && fromDS) {
               // AP -> Client: addr1=client, addr2=BSSID
               memcpy(clientMac, payload + 4, 6);
               memcpy(bssid, payload + 10, 6);
           } else {
               return;  // WDS or IBSS, ignore
           }
           
           // [P2] Verify BSSID matches monitored network
           if (!macEqual(bssid, monitoredBSSID)) return;
           
           // Skip broadcast/multicast clients
           if (clientMac[0] & 0x01) return;
           
           trackClient(bssid, clientMac, rssi);
       }
    
    4. Implement trackClient() [P3]:
       
       void SpectrumMode::trackClient(const uint8_t* bssid, const uint8_t* clientMac, int8_t rssi) {
           // Bounds check [P3]
           if (monitoredNetworkIndex < 0 || monitoredNetworkIndex >= (int)networks.size()) {
               exitClientMonitor();  // Network gone, bail out
               return;
           }
           
           SpectrumNetwork& net = networks[monitoredNetworkIndex];
           
           // Double-check BSSID still matches [P2]
           if (!macEqual(net.bssid, monitoredBSSID)) {
               exitClientMonitor();
               return;
           }
           
           uint32_t now = millis();
           
           // Check if client already tracked
           for (int i = 0; i < net.clientCount; i++) {
               if (macEqual(net.clients[i].mac, clientMac)) {
                   net.clients[i].rssi = rssi;
                   net.clients[i].lastSeen = now;
                   return;  // Updated existing
               }
           }
           
           // Add new client if room
           if (net.clientCount < MAX_SPECTRUM_CLIENTS) {
               memcpy(net.clients[net.clientCount].mac, clientMac, 6);
               net.clients[net.clientCount].rssi = rssi;
               net.clients[net.clientCount].lastSeen = now;
               net.clientCount++;
               // Optional: XP::addXP(XPEvent::CLIENT_DISCOVERED);
           }
       }


====[ PHASE 3: CHANNEL LOCKING ]====

    Mitigations: [P2] [P4] [P5]
    
    Files to modify:
    - src/modes/spectrum.cpp
    
    Changes to update():
    1. When monitoringNetwork is true, SKIP channel hopping:
       
       if (!monitoringNetwork) {
           // Existing channel hop code
           if (now - lastHopTime > 100) {
               currentChannel = (currentChannel % 13) + 1;
               esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
               lastHopTime = now;
           }
       }
       
    2. Add network validity check every update [P2]:
       
       if (monitoringNetwork) {
           // Verify monitored network still exists
           if (monitoredNetworkIndex >= (int)networks.size() ||
               !macEqual(networks[monitoredNetworkIndex].bssid, monitoredBSSID)) {
               // Network disappeared or got shuffled
               Display::showToast("Network lost");
               exitClientMonitor();
           }
       }
    
    Changes to enterClientMonitor() [P5]:
    
       void SpectrumMode::enterClientMonitor() {
           spectrumBusy = true;  // [P5] Block callback FIRST
           
           // Bounds check [P3]
           if (selectedIndex < 0 || selectedIndex >= (int)networks.size()) {
               spectrumBusy = false;
               return;
           }
           
           SpectrumNetwork& net = networks[selectedIndex];
           
           // Store BSSID separately [P2]
           memcpy(monitoredBSSID, net.bssid, 6);
           monitoredNetworkIndex = selectedIndex;
           monitoredChannel = net.channel;
           
           // Clear any old client data [P6]
           net.clientCount = 0;
           
           // Reset UI state
           clientScrollOffset = 0;
           selectedClientIndex = 0;
           
           // Lock channel
           esp_wifi_set_channel(monitoredChannel, WIFI_SECOND_CHAN_NONE);
           
           // NOW enable monitoring (after all state is ready) [P5]
           monitoringNetwork = true;
           
           spectrumBusy = false;
       }
    
    Changes to exitClientMonitor() [P4] [P5]:
    
       void SpectrumMode::exitClientMonitor() {
           spectrumBusy = true;  // [P5] Block callback FIRST
           
           monitoringNetwork = false;  // [P4] Disable monitoring immediately
           
           // Clear client data to free memory [P6]
           if (monitoredNetworkIndex >= 0 && 
               monitoredNetworkIndex < (int)networks.size()) {
               networks[monitoredNetworkIndex].clientCount = 0;
           }
           
           // Reset indices
           monitoredNetworkIndex = -1;
           memset(monitoredBSSID, 0, 6);
           
           spectrumBusy = false;
           
           // Channel hopping resumes automatically in next update()
       }
    
    Changes to stop() [P4]:
    
       void SpectrumMode::stop() {
           monitoringNetwork = false;  // [P4] Ensure hopping can resume
           // ... existing cleanup ...
       }


====[ PHASE 4: INPUT HANDLING ]====

    Mitigations: [P11] [P13] [P14]
    
    Files to modify:
    - src/modes/spectrum.cpp
    
    Changes to handleInput() [P11]:
    
       void SpectrumMode::handleInput() {
           // [P11] Single state check at TOP - no fall-through!
           if (monitoringNetwork) {
               handleClientMonitorInput();
               return;  // CRITICAL: return here, not fall through
           }
           
           // ... existing spectrum input handling ...
       }
    
    Change Enter behavior for network selection:
    
       if (keys.enter && !enterPressed && !networks.empty()) {
           enterPressed = true;
           if (selectedIndex >= 0 && selectedIndex < (int)networks.size()) {
               enterClientMonitor();  // Enter monitoring instead of centering
           }
       }
    
    Implement handleClientMonitorInput() [P13] [P14]:
    
       void SpectrumMode::handleClientMonitorInput() {
           M5Cardputer.update();
           auto& kb = M5Cardputer.Keyboard;
           
           if (!kb.isChange()) return;
           
           // Exit keys (backtick or backspace)
           if (kb.isKeyPressed('`') || kb.isKeyPressed(KEY_BACKSPACE)) {
               exitClientMonitor();
               return;
           }
           
           // B key: add to BOAR BROS and exit [P13]
           if (kb.isKeyPressed('b') || kb.isKeyPressed('B')) {
               if (monitoredNetworkIndex >= 0 && 
                   monitoredNetworkIndex < (int)networks.size()) {
                   // Call OINK's excludeNetwork or implement local version
                   Display::showToast("Excluded - returning");
                   delay(500);
                   exitClientMonitor();
               }
               return;
           }
           
           // Get client count safely [P14]
           int clientCount = 0;
           if (monitoredNetworkIndex >= 0 && 
               monitoredNetworkIndex < (int)networks.size()) {
               clientCount = networks[monitoredNetworkIndex].clientCount;
           }
           
           // Navigation only if clients exist [P14]
           if (clientCount > 0) {
               if (kb.isKeyPressed(';')) {
                   selectedClientIndex = max(0, selectedClientIndex - 1);
                   // Adjust scroll if needed
                   if (selectedClientIndex < clientScrollOffset) {
                       clientScrollOffset = selectedClientIndex;
                   }
               }
               
               if (kb.isKeyPressed('.')) {
                   selectedClientIndex = min(clientCount - 1, selectedClientIndex + 1);
                   // Adjust scroll if needed
                   if (selectedClientIndex >= clientScrollOffset + VISIBLE_CLIENTS) {
                       clientScrollOffset = selectedClientIndex - VISIBLE_CLIENTS + 1;
                   }
               }
               
               // Enter: show client detail [P14]
               if (kb.isKeyPressed(KEY_ENTER)) {
                   showClientDetail(selectedClientIndex);
               }
           }
       }


====[ PHASE 5: CLIENT OVERLAY UI ]====

    Mitigations: [P3] [P9] [P12] [P14] [P15]
    
    Files to modify:
    - src/modes/spectrum.cpp
    
    Implement drawClientOverlay(M5Canvas& canvas) [P12] [P14] [P15]:
    
       void SpectrumMode::drawClientOverlay(M5Canvas& canvas) {
           // [P12] Draw in mainCanvas area only (y=0 to y=90 max)
           // XP bar is at y=91, leave it alone
           
           canvas.fillRect(0, 0, 240, 90, COLOR_BG);  // Clear main area only
           
           // Bounds check [P3]
           if (monitoredNetworkIndex < 0 || 
               monitoredNetworkIndex >= (int)networks.size()) {
               canvas.drawString("Network lost", 120, 45);
               return;
           }
           
           SpectrumNetwork& net = networks[monitoredNetworkIndex];
           
           // Header: SSID or <hidden> [P15]
           char header[32];
           if (net.ssid[0] == 0) {
               snprintf(header, sizeof(header), "CLIENTS: <hidden>");
           } else {
               char truncSSID[16];
               strncpy(truncSSID, net.ssid, 15);
               truncSSID[15] = '\0';  // [P9] Explicit null termination
               snprintf(header, sizeof(header), "CLIENTS: %s", truncSSID);
           }
           canvas.setTextDatum(top_left);
           canvas.drawString(header, 4, 2);
           
           // Empty list message [P14]
           if (net.clientCount == 0) {
               canvas.setTextDatum(middle_center);
               canvas.drawString("No clients detected", 120, 45);
               canvas.drawString("Waiting for data frames...", 120, 60);
               return;
           }
           
           // Client list (starts at y=18, 18px per line, max 4 visible)
           const int VISIBLE_CLIENTS = 4;
           const int LINE_HEIGHT = 18;
           const int START_Y = 18;
           
           for (int i = 0; i < VISIBLE_CLIENTS && (i + clientScrollOffset) < net.clientCount; i++) {
               int clientIdx = i + clientScrollOffset;
               
               // Bounds check [P3]
               if (clientIdx >= net.clientCount) break;
               
               SpectrumClient& client = net.clients[clientIdx];
               
               int y = START_Y + (i * LINE_HEIGHT);
               bool selected = (clientIdx == selectedClientIndex);
               
               // Highlight selected row
               if (selected) {
                   canvas.fillRect(0, y, 240, LINE_HEIGHT, COLOR_FG);
                   canvas.setTextColor(COLOR_BG, COLOR_FG);
               } else {
                   canvas.setTextColor(COLOR_FG, COLOR_BG);
               }
               
               // Format: "1. Vendor    XX:XX:XX  -XXdB  Xs"
               char line[48];
               const char* vendor = OUI::getVendor(client.mac);
               uint32_t age = (millis() - client.lastSeen) / 1000;
               
               // [P9] Safe string formatting with bounds
               snprintf(line, sizeof(line), "%d. %-9.9s %02X:%02X:%02X %4ddB %lus",
                   clientIdx + 1,
                   vendor,
                   client.mac[0], client.mac[1], client.mac[2],
                   client.rssi,
                   age);
               
               canvas.drawString(line, 4, y + 2);
           }
           
           // Scroll indicators
           if (clientScrollOffset > 0) {
               canvas.drawString("^", 230, 18);  // More above
           }
           if (clientScrollOffset + VISIBLE_CLIENTS < net.clientCount) {
               canvas.drawString("v", 230, 72);  // More below
           }
           
           // Bottom hint (y=76-90 area)
           canvas.setTextColor(COLOR_FG, COLOR_BG);
           canvas.setTextDatum(bottom_center);
           canvas.drawString("[;/.] nav  [Enter] detail  [`] back", 120, 88);
       }
    
    Client detail popup implementation [P3] [P9]:
    
       void SpectrumMode::showClientDetail(int idx) {
           // Bounds check [P3]
           if (monitoredNetworkIndex < 0 || 
               monitoredNetworkIndex >= (int)networks.size()) return;
           if (idx < 0 || idx >= networks[monitoredNetworkIndex].clientCount) return;
           
           SpectrumClient& client = networks[monitoredNetworkIndex].clients[idx];
           
           // Format full MAC [P9]
           char macStr[18];
           snprintf(macStr, sizeof(macStr), "%02X:%02X:%02X:%02X:%02X:%02X",
               client.mac[0], client.mac[1], client.mac[2],
               client.mac[3], client.mac[4], client.mac[5]);
           
           const char* vendor = OUI::getVendor(client.mac);
           uint32_t age = (millis() - client.lastSeen) / 1000;
           
           // Show toast-style popup (reuse Display::showToast pattern)
           // Auto-dismiss after 3s or any key
           Display::showClientPopup(macStr, vendor, client.rssi, age);
       }


====[ PHASE 6: MAC VENDOR LOOKUP (OUI DATABASE) ]====

    Mitigations: [P7] [P9]
    
    New files:
    - src/core/oui.h
    - src/core/oui.cpp
    
    Implementation approach: EMBEDDED COMPACT TABLE
    - ~50KB flash for top 500 vendors
    - Covers 90%+ of devices seen in the wild
    - No SD card required
    - Linear search (500 entries = ~50μs, acceptable) [P7]
    
    Data structure [P9]:
    
       struct OUIEntry {
           uint8_t oui[3];      // First 3 bytes of MAC
           char vendor[10];     // 9 chars max + null [P9]
       };
       
       // MUST be sorted by OUI for future binary search optimization
       static const OUIEntry OUI_TABLE[] PROGMEM = {
           {{0x00, 0x00, 0x0C}, "Cisco"},
           {{0x00, 0x03, 0x93}, "Apple"},
           {{0x00, 0x0C, 0x29}, "VMware"},
           {{0x00, 0x14, 0x22}, "Dell"},
           {{0x00, 0x17, 0xC4}, "Quanta"},
           {{0x00, 0x1A, 0x11}, "Google"},
           {{0x00, 0x24, 0xE8}, "Dell"},
           {{0x00, 0x25, 0x00}, "Apple"},
           {{0x00, 0x26, 0xBB}, "Apple"},
           // ... ~500 entries total
       };
       
       #define OUI_TABLE_SIZE (sizeof(OUI_TABLE) / sizeof(OUI_TABLE[0]))
    
    Functions [P7]:
    
       // oui.h
       namespace OUI {
           const char* getVendor(const uint8_t* mac);
           bool selfTest();  // [P7] Verify table is valid
       }
       
       // oui.cpp
       const char* OUI::getVendor(const uint8_t* mac) {
           // Linear search for now (simple, reliable) [P7]
           for (size_t i = 0; i < OUI_TABLE_SIZE; i++) {
               if (mac[0] == OUI_TABLE[i].oui[0] &&
                   mac[1] == OUI_TABLE[i].oui[1] &&
                   mac[2] == OUI_TABLE[i].oui[2]) {
                   return OUI_TABLE[i].vendor;
               }
           }
           return "Unknown";
       }
       
       bool OUI::selfTest() {
           // [P7] Verify table integrity at startup
           // Check that entries are sorted (for future binary search)
           for (size_t i = 1; i < OUI_TABLE_SIZE; i++) {
               uint32_t prev = (OUI_TABLE[i-1].oui[0] << 16) | 
                               (OUI_TABLE[i-1].oui[1] << 8) | 
                               OUI_TABLE[i-1].oui[2];
               uint32_t curr = (OUI_TABLE[i].oui[0] << 16) | 
                               (OUI_TABLE[i].oui[1] << 8) | 
                               OUI_TABLE[i].oui[2];
               if (curr <= prev) {
                   Serial.printf("[OUI] Table not sorted at index %d\n", i);
                   return false;
               }
           }
           Serial.printf("[OUI] Self-test passed, %d vendors loaded\n", OUI_TABLE_SIZE);
           return true;
       }
    
    Vendor name truncation rules [P9]:
    - "Apple, Inc." -> "Apple"
    - "Samsung Electronics Co.,Ltd" -> "Samsung"
    - "Intel Corporate" -> "Intel"
    - "Google, Inc." -> "Google"
    - "Huawei Technologies Co.,Ltd" -> "Huawei"
    - "Microsoft Corporation" -> "Microsoft"
    - "Hon Hai Precision" -> "HonHai" (Foxconn)
    - "Raspberry Pi Foundation" -> "RaspbPi"
    
    Source for OUI data:
    - IEEE public OUI list: standards-oui.ieee.org/oui/oui.txt
    - Filter to top 500 by frequency (use existing wardriving data)
    - MIT licensed alternative: https://github.com/wireshark/wireshark/blob/master/manuf


====[ PHASE 7: BOTTOM BAR INTEGRATION ]====

    Mitigations: [P3] [P9] [P15]
    
    Files to modify:
    - src/ui/display.cpp (drawBottomBar function)
    - src/modes/spectrum.h (add accessor methods)
    
    Add to spectrum.h:
    
       static bool isMonitoring() { return monitoringNetwork; }
       static String getMonitoredSSID();
       static int getClientCount();
       static uint8_t getMonitoredChannel();
    
    Implement in spectrum.cpp [P3] [P15]:
    
       String SpectrumMode::getMonitoredSSID() {
           if (!monitoringNetwork) return "";
           if (monitoredNetworkIndex < 0 || 
               monitoredNetworkIndex >= (int)networks.size()) return "";
           
           const char* ssid = networks[monitoredNetworkIndex].ssid;
           if (ssid[0] == 0) return "<hidden>";  // [P15]
           
           // Truncate for bottom bar [P9]
           char truncated[12];
           strncpy(truncated, ssid, 11);
           truncated[11] = '\0';
           return String(truncated);
       }
       
       int SpectrumMode::getClientCount() {
           if (!monitoringNetwork) return 0;
           if (monitoredNetworkIndex < 0 || 
               monitoredNetworkIndex >= (int)networks.size()) return 0;  // [P3]
           return networks[monitoredNetworkIndex].clientCount;
       }
       
       uint8_t SpectrumMode::getMonitoredChannel() {
           return monitoredChannel;
       }
    
    Changes to drawBottomBar() in display.cpp:
    
       case PorkchopMode::SPECTRUM_MODE:
           if (SpectrumMode::isMonitoring()) {
               // Show monitoring stats
               char buf[40];
               snprintf(buf, sizeof(buf), "WATCH: %s CH:%d C:%d",
                   SpectrumMode::getMonitoredSSID().c_str(),
                   SpectrumMode::getMonitoredChannel(),
                   SpectrumMode::getClientCount());
               bottomBar.drawString(buf, 4, 1);
           } else {
               // Existing spectrum bottom bar
               // ... current code ...
           }
           break;


====[ PHASE 8: STALE CLIENT CLEANUP ]====

    Mitigations: [P1] [P3] [P10]
    
    Files to modify:
    - src/modes/spectrum.cpp
    
    Add client pruning in update() when monitoring [P1] [P10]:
    
       // Call every 5 seconds when monitoring
       static uint32_t lastClientPrune = 0;
       if (monitoringNetwork && (now - lastClientPrune > 5000)) {
           lastClientPrune = now;
           pruneStaleClients();
       }
    
    Implement pruneStaleClients() [P3] [P10]:
    
       void SpectrumMode::pruneStaleClients() {
           spectrumBusy = true;  // [P1] Block callback
           
           // Bounds check [P3]
           if (monitoredNetworkIndex < 0 || 
               monitoredNetworkIndex >= (int)networks.size()) {
               spectrumBusy = false;
               return;
           }
           
           SpectrumNetwork& net = networks[monitoredNetworkIndex];
           uint32_t now = millis();
           
           // [P10] Iterate BACKWARDS to handle removal safely
           for (int i = net.clientCount - 1; i >= 0; i--) {
               if ((now - net.clients[i].lastSeen) > CLIENT_STALE_TIMEOUT_MS) {
                   // Remove this client by shifting array
                   for (int j = i; j < net.clientCount - 1; j++) {
                       net.clients[j] = net.clients[j + 1];
                   }
                   net.clientCount--;
               }
           }
           
           // [P3] Fix selectedClientIndex if now out of bounds
           if (net.clientCount == 0) {
               selectedClientIndex = 0;
               clientScrollOffset = 0;
           } else if (selectedClientIndex >= net.clientCount) {
               selectedClientIndex = net.clientCount - 1;
           }
           
           // Fix scroll offset if needed
           if (clientScrollOffset > 0 && 
               clientScrollOffset >= net.clientCount) {
               clientScrollOffset = max(0, net.clientCount - VISIBLE_CLIENTS);
           }
           
           spectrumBusy = false;
       }


====[ PHASE 9: TESTING & POLISH ]====

    Manual testing checklist (with pitfall references):
    
    Basic functionality:
    [ ] Enter SPECTRUM mode, verify channel hopping works
    [ ] Press Enter on network, verify channel locks [P4]
    [ ] Verify data frames captured (Serial debug)
    [ ] Verify client appears in overlay
    [ ] Test vendor lookup for known devices (iPhone=Apple, Galaxy=Samsung)
    [ ] Test scroll with ; and . [P14]
    [ ] Test client detail popup with Enter [P14]
    [ ] Test exit with ` (backtick) [P4]
    [ ] Verify channel hopping resumes after exit [P4]
    
    Race condition testing [P1] [P5]:
    [ ] Rapid Enter/Exit cycling (10x fast)
    [ ] Enter/Exit while data frames arriving
    [ ] Exit during client prune operation
    [ ] Serial output shows no crash/corruption
    
    Edge cases:
    [ ] Network disappears while monitoring [P2] - should auto-exit with toast
    [ ] 8+ clients - verify cap and scroll [P3]
    [ ] Very long SSID - verify truncation [P9]
    [ ] Hidden network - verify "<hidden>" display [P15]
    [ ] No clients connected - verify empty list message [P14]
    [ ] Stale client removal after 30s [P10]
    
    Memory testing:
    [ ] Monitor heap during extended monitoring session (10 min)
    [ ] Verify clientCount=0 after exitClientMonitor [P6]
    [ ] Check heap after multiple enter/exit cycles
    
    Integration testing:
    [ ] XP bar still visible in overlay [P12]
    [ ] BOAR BROS exclusion with B key [P13]
    [ ] Bottom bar shows correct info when monitoring
    [ ] OUI::selfTest() passes at boot [P7]
    
    Regression testing:
    [ ] Spectrum view still works normally (no monitoring)
    [ ] Network selection/centering when NOT monitoring
    [ ] Channel hopping timing unchanged
    [ ] Gaussian lobe rendering unaffected


--[ BUG TRIAGE PROTOCOL

    When a bug is found during testing:
    
    1. Identify which pitfall category it matches (P1-P15)
    2. Check if the mitigation was implemented correctly
    3. If new category, add to KNOWN PITFALLS section
    4. Document reproduction steps in this file
    5. Fix and add test case to checklist


--[ FILE CHANGE SUMMARY

    Modified files:
    1. src/modes/spectrum.h      - Client structs, monitoring state, busy guard
    2. src/modes/spectrum.cpp    - Main implementation (~300 lines with mitigations)
    3. src/ui/display.cpp        - Bottom bar monitoring info, showClientPopup()
    
    New files:
    4. src/core/oui.h            - OUI lookup header + selfTest()
    5. src/core/oui.cpp          - Embedded OUI table (~50KB) with validation
    
    Optional:
    6. src/core/xp.cpp           - New XP event for client discovery
    7. src/core/xp.h             - CLIENT_DISCOVERED event enum


--[ ESTIMATED EFFORT

    Phase 1 (Data Structures):      45 min (added busy guard, BSSID storage)
    Phase 2 (Data Frame Capture):   1.5 hours (full implementation with guards)
    Phase 3 (Channel Locking):      1 hour (enter/exit with proper ordering)
    Phase 4 (Input Handling):       1 hour (state separation, empty list handling)
    Phase 5 (Client Overlay UI):    2 hours (bounds checks, hidden network)
    Phase 6 (OUI Database):         2 hours (data prep, selfTest, linear search)
    Phase 7 (Bottom Bar):           30 min (accessor methods with guards)
    Phase 8 (Stale Cleanup):        45 min (backwards iteration, index clamping)
    Phase 9 (Testing):              2 hours (expanded checklist with pitfall refs)
    
    Total: ~11-12 hours over 2-3 sessions
    
    Note: Extra time accounts for defensive programming. This is CHEAPER
    than debugging race conditions after the fact. Trust me on this one.


--[ DEPENDENCIES

    No new library dependencies.
    OUI data from public IEEE database (no license issues).
    Reuses existing UI patterns and code from OINK mode.


--[ CRITICAL INVARIANTS

    These conditions MUST always be true. If violated, exit monitor mode.
    
    1. When monitoringNetwork == true:
       - monitoredNetworkIndex is valid (0 <= idx < networks.size())
       - networks[monitoredNetworkIndex].bssid == monitoredBSSID
       - monitoredChannel == networks[monitoredNetworkIndex].channel
    
    2. When modifying networks or clients arrays:
       - spectrumBusy == true
       - No callback processing occurs
    
    3. After any array modification:
       - selectedClientIndex < clientCount (or 0 if empty)
       - clientScrollOffset < clientCount (or 0 if empty)
       - monitoredNetworkIndex still valid (or exit monitor)
    
    4. On exitClientMonitor() completion:
       - monitoringNetwork == false
       - Client data cleared (clientCount = 0)
       - Channel hopping will resume on next update()


--[ FUTURE ENHANCEMENTS (NOT IN v0.1.6)

    - D key to deauth selected client directly from monitor
    - Export client list to CSV
    - Client history (persist across sessions)
    - Probe request tracking for selected client
    - "Follow" mode - track specific client across networks


==[EOF]==
